import{_ as e,o as t,c as r,R as o}from"./chunks/framework.Vrn_wj7i.js";const f=JSON.parse('{"title":"微前端学习","description":"","frontmatter":{"title":"微前端学习","date":"2023-02-14T15:49:55.000Z","tags":"微前端","summary":"微前端学习","categories":"MicroFront"},"headers":[],"relativePath":"files/MicroFront/introduce.md","filePath":"files/MicroFront/introduce.md"}'),a={name:"files/MicroFront/introduce.md"},n=o('<h1 id="微前端" tabindex="-1">微前端 <a class="header-anchor" href="#微前端" aria-label="Permalink to &quot;微前端&quot;">​</a></h1><h2 id="什么是微前端" tabindex="-1">什么是微前端 ❓ <a class="header-anchor" href="#什么是微前端" aria-label="Permalink to &quot;什么是微前端 :question:&quot;">​</a></h2><blockquote><p>Techniques, strategies and recipes for building a <strong>modern web app</strong> with <strong>multiple teams</strong> that can <strong>ship features independently</strong> <a href="https://micro-frontends.org/" target="_blank" rel="noreferrer"> -- Micro Frontend</a> <br> 微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。<br></p></blockquote><h2 id="产生原因" tabindex="-1">产生原因 📃 <a class="header-anchor" href="#产生原因" aria-label="Permalink to &quot;产生原因 :page_with_curl:&quot;">​</a></h2><blockquote><p>Over time the frontend layer, often developed by a separate team, grows and gets more difficult to maintain. That’s what we call a Frontend Monolith.<a href="https://micro-frontends.org/" target="_blank" rel="noreferrer"> -- Micro Frontend</a> <br> 随着时间的推移，项目会越来越大，越来越难以维护。这就是我们所说的巨石应用。</p></blockquote><h2 id="实现思想" tabindex="-1">实现思想 💡 <a class="header-anchor" href="#实现思想" aria-label="Permalink to &quot;实现思想 :bulb:&quot;">​</a></h2><ul><li><strong>技术栈无关</strong><br>主框架不限制接入应用的技术栈，微应用具备完全自主权</li><li><strong>独立开发、独立部署</strong><br>微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</li><li><strong>增量升级</strong><br>在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略</li><li><strong>状态隔离</strong><br>每个微应用之间状态隔离，运行时状态不共享</li></ul>',7),i=[n];function s(l,c,d,h,u,_){return t(),r("div",null,i)}const g=e(a,[["render",s]]);export{f as __pageData,g as default};
